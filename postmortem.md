# Postmortem

Here are some thoughts about using Carp in the Lisp Game Jam 2018. The jam was ten days long but I only got about three days of actual work done. In the end I didn't manage to complete the game, though it's kinda playable if you have some imagination :) My plan is to eventually finish it up and let it be an example that other people can learn from when coming to Carp. Anyways - it was very fun to do a project in the language and I learned a lot, here are some thoughts:

## Good stuff
* *Memory management seems to work well (?!).* I didn't run into any memory bugs and from what I can tell there are no leaks in the current version of the game. Actually there are no calls to `malloc` at all after setup, which is *very* nice. The lack of lifetimes still make it possible to write unsafe code though, so fixing that is important going forward (I just manually avoided those bugs since I know about them).
* *It's kinda fun.* The end goal with Carp (for me!) is to have a more pleasant tool to work with in my day job (making games). While things are not exactly there yet, I do find it pretty enjoyable to write code in the language - at least for this kind of small project: Compile times are short, error messages have been mostly adequate, static types are nice (though limiting in it's current incarnation), and the lisp syntax allows for fast structural editing / refactoring.
* *Writing games in a data oriented way is easy.* Instead of lamenting the lack of union types (which *are* coming, I promise) I designed the data of the game in a very old-school "arrays of structs" kind of way. Each kind of component (entities, ai, player input, etc) is packed into one array each. To get hold of other components I use indexes into those arrays. This makes the whole game state very easy to inspect and understand, plus it's good for the processor's cache. It also makes it easy to add new components without touching the existing code. While this kind of architecture is very non-lispy in a way, it makes a whole lot of sense for games.

## Bad stuff
* *Programming in a functional style in Carp is way too hard,* mainly due to the current lack of closures. This was the major pain point when writing most of the game logic and it forced me to use mutation in a lot of places where my first thought was a simple call to `map`. Fixing this has a *very* high priority going forward, the current game uses too much imperative code I think.
* *Generic structs seem to have some problems.* I tried making my game object type generic to allow for some flexibility but it failed with obscure errors about unresolved types. Fixing these bugs is also very important - generic types must be a 100% robust.
* *The standard library still lacks functionality.* Turns out you need a lot of functions in a standard library, I kept adding stuff to it throughout the whole project. This usually isn't much of a problem, these kinds of functions are easy to implement and provide great value. Having to write them just isn't very good for your flow, especially when working under time pressure (which is what game jams are all about!)
